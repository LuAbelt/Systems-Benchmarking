\documentclass[	runningheads,
				%deutsch, % Tell llncs that the keywords should be in german
				%german,  % Needed for the \ifgerman-command
				a4paper]{llncs}

\usepackage{url}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{hyperref}

% Support for special characters like "Umlaute"
\usepackage[utf8]{inputenc}

\usepackage[english]{babel}

\usepackage{glossaries}

\makeglossaries

\loadglsentries{glossary}
%*********************************************************************%
% META                                                                %
%*********************************************************************%
\newcommand{\university}{Saarland University}
\newcommand{\school}{Saarland Informatics Campus}
\newcommand{\thetitle}{Seminar: Systems Benchmarking}
\newcommand{\shorttitle}{Seminar: Systems Benchmarking}
\newcommand{\thedate}{\today{}}
\newcommand{\thegermandate}{15. April}

\newcommand{\theforename}{Lukas}
\newcommand{\thesurname}{Abelt}

% Advisors
	\newcommand{\advisor}{Advisors}
	\newcommand{\advisors}{Prof. Sven Apel, \\ Christian Hechtl}

% Title for the seminar
\newcommand{\theseminartitle}{"Performance Measurements Before Releases vs. Each Commits"}
%\newcommand{\theseminartitle}{"Using Benchmarking in Productive Development Systems -- Opportunities and Challenges"}

%*********************************************************************%
% THE DOCUMENT                                                        %
%*********************************************************************%

\begin{document}
	%*********************************************************************%
	% TITLE                                                               %
	%*********************************************************************%
	
	% Arabic page numbering
	\mainmatter 
		
	% Title including a subtitle for the name of the seminar
	\title{\theseminartitle \\ \small \thetitle}
	
	% (Optional) In the case that the initial title is too long, the short title will be used
	%\titlerunning{Hauptseminar: Human and Social Factors in Software Engineering}
	
	\author{\theforename\ \thesurname \small \\ \ \\ \advisor : \ \advisors}
	
	% (Optional) This will appear near the page number
	\authorrunning{\shorttitle}
	
	\institute{\school ,\\ \university}
	
	\maketitle
	
	%*********************************************************************%
	% CONTENT                                                             %
	%*********************************************************************%

% General Structure
	% 1. Introduction and Motivation
	% 2. General Definitions
	%		2.1 What is a Benchmark
	%		2.2 What is a continuous Benchmark
	% 3. Experiment
	%		3.1 Experiment Idea&Goals
	%		3.2 Setup
	%		3.3 Evaluation
	%	4. 

	% Introduction
\section{Introduction}
Over the past years system benchmarks have become more prominent in a variety of contexts and use cases. As a result more benchmarking tools became available that are used in both commercial systems and are widely adopted for academic purposes.

In this paper we give an overview of the general concepts of system benchmarks before we consider in detail how classical benchmarking approaches can be used and extended to integrate it into the standard development process of software. Specifically, we take a look at how benchmark can be used to swiftly detect and react to performance changes throughout the development process. In order to do this we will take a look at Change-Point detection algorithms. We will outline and analyse the methodology and opportunities of such approaches while taking a careful look at the challenges that may arise due to this.

To support and evaluate our claims, we will conduct a practical experiment where we will use and compare several benchmarking techniques on a piece of well known, open-source software.

\section{System Benchmarks}
\label{sec:benchmarking}
The term "Benchmark" is a broad term that can be interpreted and defined in many different ways depending on the context and application domain. We will use this chapter to give a definition of Benchmarking how we will use it throughout this paper.

\subsection{Definition}
\label{ssec:bench_definition}
The term "Benchmark" is used in a variety of different domains and, according to the Standard Specialization Evaluation Corporation, historically stems from a physical marking that was used as a reference point on a workbench to check the length of the produced pieces\footnote{SPEC Glossary: \url{https://www.spec.org/spec/glossary/\#benchmark}}. However throughout this paper we are only interested in system benchmarks within the context of software systems and will therefore also refer to the definition of a benchmark as given by Kounev et al.: "a tool coupled with a methodology for the evaluation and comparison of systems or components with respect to specific characteristics, such as performance, reliability or security." (\cite{Kounev} p. 4). As already given from this definition benchmarks can serve as an evaluation for different characteristics. We will more closely look at these in \autoref{ssec:bench_classification}. Throughout this paper we will also mostly refer to the "system or component" that is being benchmarked as the \gls{sut}.

\subsection{Classification of Benchmarks}
\label{ssec:bench_classification}
Benchmarks can be classified in a variety of different means. In this section we will give a small overview of the different types of benchmarks there are with respect to the two following questions:
\begin{enumerate}
	\item What overall goal does a benchmark serve?
	\item What qualities are evaluated by an benchmark?
	\item How can a benchmark be performed (Benchmarking strategies)
\end{enumerate}

In the broadest sense, benchmarks can be divided into competitive and non-competitive benchmarks. The main motivation of competitive benchmarks is hereby the development of standardized quality criteria that can be used to compare different systems. Certain sources also emphasize this importance on the competitiveness by providing a more detailed definition of the term benchmark, i.e. "a standard tool for competitive evaluation and comparison of competitive systems" (\cite{kistowski2015} p. X).

For non-competitive benchmarks Kounev et al. Further distinguish between the two categories of "rating tools" and "research benchmark". Rating tools can serve multiple purposes: Either as a component of an development and system improvement process, as a baseline for regulatory programmes or to serve as common benchmark for research. Research benchmarks on the other hand commonly refer to tools and workloads that may be used for in-depth evaluation of research results, prototypes or productive systems. Based on these descriptions it becomes apparent that there sometimes might be no clear distinction between a rating tool and a research benchmark and the terminology is often determined by the evaluating party (See \cite{Kounev} p. 4).

Regardless of the competitiveness, or lack thereof, of a benchmark the key metrics that are evaluated are often similar or even identical. While historically the main metrics of importance were e.g. security, system reliability and energy efficiency, modern benchmarks also try to cover much more aspects of a software. We will discuss a selection of the quality attributes listed by Kounev et al. that are usually target of modern benchmarks(\cite{Kounev} p. 6 f):

\paragraph{Performance} The term Performance itself can be interpreted in many different means. For this paper, we will focus on one of the most basic interpretations: The amount of work done compared to the time and resources used. A much more in-depth explanation of different performance measures is given by Kounev et al. (See \cite{Kounev} p. 49 ff)

\paragraph{Scalability} TODO Definition needed

\paragraph{Energy Efficiency} TODO Definition needed

\paragraph{Reliability} TODO Definition needed

When it comes to benchmarking strategies two approaches are most prominent: Fixed-Time and Fixed-Work benchmarks. A Fixed-Work Benchmark here describes the most intuitive approach for benchmarking: We fix a specified amount of work $W_i$ and measure the required time $T_i$ that is required to fulfil this work.

While Fixed-Work benchmarks are easy to understand and implement, it introduces an implicit performance bottleneck that is also known as \textit{Amdahl's Law}. It states that the maximum possible performance improvement that can be achieved in Fixed-Work Benchmarks is prohibitly upper-bounded by the fraction of work that is performed by the component that is being improved (See \cite{Kounev} p. 9f).

In Fixed-Time benchmarks, instead of fixing the amount of work $W_i$, the time $T_i$ is bound and the amount of work finished in this time is measured as a metric. As opposed to Fixed-Work Benchmarks the Fixed-Time Benchmarks do not suffer the issue of an upper-bounded maximum improvement as for every improvement, the reduced time can be used to process further work units (See \cite{Kounev} p. 11).

Additionally there are also further approaches that does not employ fixed time or work at all, but rather employ variable-time and -work characteristics. For this case the metric is a function of the time $T$ and the work $W$. While this technique provides maximum flexibility, this approach is not suitable for all types of benchmarks (See \cite{Kounev} p. 12)

\subsection{Evaluating Benchmarks}

Apart from the metrics that evaluate the result of a benchmark, there are also several attributes that are important to evaluate the quality of the benchmark itself. The designer of a benchmark should always take these attributes into consideration when creating a benchmark. As described by Skadron et al. it is not possible to create a single benchmark that covers all these attributes perfectly. Therefore one either has to create multiple benchmarks that complement each others weaknesses or choose to sacrifice one of these attributes over the other (\cite{Skadron2003} p. 32f).

Over the years, researchers and industry associates alike have defined several criteria that are considered desirable by modern standards. Often the exact terminology of these criteria differs based on authors and the specific application domain, however the concepts in general are similar. Kounev at al. list five core criteria that will be defined in a little more detail in this chapter (\cite{Kounev} p. 13f). A much more in depth discussion of these criteria was performed by Kistowski et al. (See \cite{kistowski2015})

\paragraph{Relevance} For a benchmark to be meaningful it is important that it, at least to a certain extent, reproduces some scenarios with real world application. This is what the "Relevance" of a benchmark refers to. It tries to define how relevant the produced information is to a potential user of a software. According to Kistowski et al. this makes it "perhaps the most important characteristic" (\cite{kistowski2015} p. 334). However the relevance of a benchmark may also limits the benchmarks applicability meaning, that a highly relevant benchmark for a specific system or component might only narrow applicability while benchmarks with a broad applicability will have a lower relevance but for a wider selection of applications. Kistowski et al. further elaborate on this with specific examples (\cite{kitowski2015} p. 334f)

\paragraph{Reproducibility} Reproducibility ensures that it is possible for a third party to produce ideally the same results for a given test environment. Reproducibility covers both the consistency between multiple runs on the same system as well as creating the same results on another environment with a semantically equivalent configuration. 

However, with modern hard- and software systems, optimal reproducibility has become challenging. For both hard- and software there are several factors that induce variability. From a hardware side things such as the physical disc layout or network connections may affect benchmarking results. For software systems the causes for variability stem from various different sources. from a low-level perspective, things such as thread scheduling can influence the benchmark results. From a higher level perspective a benchmark has to consider the configurability of a software system itself. Modern software systems often offer lots of different configuration options which can be used to create a tailor made system-variant. En- or disabling a specific feature might heavily influence the performance of a benchmark.

According to Huppler, an ideal benchmark result should be definable as a function of a hard- and software configuration (See \cite{huppler2009} p. 335). However for real-world applications, modelling such a function is far too complex which requires the benchmark designer to try to model reproducibility in other ways. In the end the reproducibility of a benchmark is heavily dependent on the ability to reproduce the benchmarking environment that was used to create this specific benchmark. 

\paragraph{Fairness} TODO: Short explanation
\paragraph{Verifiability} TODO: Short explanation
\paragraph{Usability} TODO: Short explanation

\section{Using Benchmarks to Detect Performance Changes}
\label{sec:bench_perf_changes}
	This section will discuss how benchmarks can be used during software development to detect performance changes.
	
	\subsection{Opportunities}
	\label{ssec:bench_perf_oppo}
	While benchmarks as a stand-alone tooling are already a useful tool to compare the performance of different systems in order to, for example, select a specific system for a given task it also offers different opportunities. One of these opportunities is to use benchmarking as a tool that is closely integrated into the development cycle in order to evaluate the systems performance throughout the development.

	There are different goals to consider when integrating benchmarking into the development process. Most prominently benchmarking can be used as a quality measure to evaluate a software systems performance. Due to the increasing complexity in modern software systems it is often not possible to foresee the impact of even a small change to the performance of a complex software system (See \cite{grambow2019} p. 1, \cite{daly2021} p. 1). 
	
	As a result if not including any performance evaluation might lead to performance regressions being shipped in a stable release to customers and users. Therefore using benchmarks throughout the development process can ensure to detect performance changes and allows to fix them before they are being released (See \cite{daly2021} p. 1). 

	Additionally employing benchmark on a regular basis also opens the window of opportunity for many other improvements if the corresponding infrastructure is setup accordingly. Daly describes in great detail how this was achieved for the MongoDB infrastructure in \cite{daly2021}. In summary the following have been observed:
	\begin{itemize}
		\item Increased productivity of the developers
		\item Reduced noise on the performance data
		\item Improved Comparison of arbitrary results
		\item An increased amount of performance improvements
	\end{itemize}

	For this chapter we want to focus on two main questions; How can performance benchmarking be used to:
	\begin{enumerate}
		\item Quickly and reliably detect performance changes?
		\item Compare arbitrary development states?
	\end{enumerate}

	The underlying overall question however is, when or how often, one needs to perform a benchmark in order to sufficiently answer these questions. For this two approaches will be compared in the following subsections:
	\begin{enumerate}
		\item Benchmarking Before Publishing a new Release
		\item Benchmarking Every Commit -- Which we will refer to a \textit{Continuous Benchmarking}
	\end{enumerate}

	\subsection{Benchmarking Before Releases}
	\label{ssec:bench_rel}
	The most intuitive approach to ensure the performance of a software system throughout the release history is quite simple: Based on the requirements imposed by either a customer or internal quality assurance one defines certain performance threshold that the software needs to fulfil. Based on these quality criteria the development team can build a benchmark that can check these attributes.

	Once the software is nearing a new release and e.g. a new \textit{Release Candidate} is created internally, the development team can use this benchmark to evaluate whether the candidate introduces a performance regression or if it is fit for a release. There are several benefits of this approach; First of all, it does not necessarily requires an automated performance testing infrastructure but rather can be executed and evaluated manually be the development team. 

	However this approach also bears various challenges that need to be considered in the development of modern software systems. Daly describes two main challenges that arose when using this approach in the development of MongoDB: Firstly it is possible that test from the last release cycle are simply not reproducible with the current software, secondly identifying the exact change that introduced a performance regression poses challenging (\cite{daly2021} p. 1f).

	Both of these challenges are heavily influenced by the length of software release cycles and the resulting amount of commits throughout one cycle. As an example one can take a look at a few open-source repositories. The C++ test framework \textit{googletest}\footnote{See \url{https://github.com/google/googletest}} by Google with it's most recent release (\textit{1.11.0}) in June 2021, while the last release before that (\textit{1.10.0}) was released in October 2019. During this period of 28 months roughly 700 commits have been added to the repository. Similarly for the C implementation of the LZ4 compression algorithm that can be found on GitHub\footnote{\url{https://github.com/lz4/lz4}} in the 15 months between the two most recent releases about 250 commits have been added to the code.

	This can also be observed in commercially used software such as MongoDB which reported about 5500 commits to their code throughout the 2019/2020 release cycle averaging to just about 15 commits per day (\cite{daly2021} p. 2). If the only benchmarking data available is these from the two release candidates this results in an extensive additional overhead to retroactively reconstruct the cause of the root cause. Additionally when only evaluating the performance before release candidates as an affect one would also only detect a performance change at that point. However generally software aims to detect performance defects as soon as possible. 

	One additional dimension that has to be considered is the aspect of configurability. In modern software systems there are often configuration options available which allows to en- and disable certain features to create a tailor-made system variant. However, this additional layer of complexity adds further challenges to benchmarking and change detection. As already very few configuration options lead to an combinatorial explosion of the possible system variants which makes it unfeasible to benchmark all of them(See \cite{apel2020} p. 1).

TODO: Elaborate how/if this can be used to compare arbitrary results

	\subsection{Continuous Benchmarking}
In this section a technique that will further be reffered to as \textit{Continuous Benchmarking} will be elaborated further. First the motivation of this approach will be discussed to give a working definition. Secondly a selection of possible continuous benchmarking strategies will be outlined. Lastly the possible benefits and potential challenges will be showcased and weighted to give an assessment of using such a technique.

	\subsubsection{Motivation \& Definition}
	As previously discussed in \autoref{ssec:bench_rel} benchmarking only before releases introduces several challenges. The general motivation of continuous benchmarking is to address these by, simply said, generally adding more data points to evaluate. These added data points can then be used for a more detailled analysis of the systems performance over time. The general idea is similar to those used in \gls{ci} and \gls{cd}. By running tests and releases more frequently, often after every commit, these methods aim to shorten release cycles. \gls{cb} however, is a term and methodology that seems not yet commonly defined in academia.

	We will therefore introduce the following (working) definition for our approach to continuous benchmarking in this paper:
	\paragraph{Continuous Benchmarking} -- A Systems Benchmarking integrated into a Continuous Integration pipeline which allows to track a (software) systems performance throughout the development process

	\subsubsection{Strategies}
	TODO: maybe remove and SPlit oppo\&Challenges into two?


		\subsubsection{Opportunities and Challenges}

	Tracking a software systems performance can be used in several ways. For this paper we want to focus on two points:
	\begin{enumerate}
		\item How can we use the performance data to detect performance changes?
		\item Can we use this data to compare the performance of different commits?
	\end{enumerate}

	\section{Change Point Detection}
	\subsection{Distinction from Outlier Detection}
	\subsection{Strategies}
	\subsubsection{Jump Detection}
	\subsubsection{Trend Detection}
	\subsubsection{E-Divisive Means}

\section{Experiment}
In this chapter we will further elaborate on the experiment that was conducted. The chapter will give an overview over the general experiment idea and it's goals, the experiment setup and the specific results that were achieved in the experiment runs. An in-depth analysis and evaluation of the experiment results is performed in \autoref{sec:exp_evaluation}

	\subsection{Experiment Idea \& Goals}
	\label{ssec:exp_goals}

	The main idea of the experiment that was created was to perform a benchmark on a series of versions of a specific open-source software to evaluate the methods and techniques described in this paper. More specifically, we want to evaluate the following questions:
	\begin{itemize}
		\item When do we need to benchmark software?
			\begin{itemize}
				\item Is it sufficient to benchmark releases?
				\item Do we need to benchmark every commit?
			\end{itemize}
		\item How do different continuous benchmarking approaches compare with respect to:
			\begin{itemize}
				\item Complexity of implementation?
				\item Reliably detecting performance changes?
				\item Reducing the amount of manual work required by the developer?
				\item Can we use this metric to compare arbitrary commits?
			\end{itemize}
	\end{itemize}

	Additionally the experiment should also be used to identify other, currently unidentified, challenges and opportunities that this approach might offer.

	For the first complex of the questions mentioned above, the following methodology is planned: Firstly, perform a benchmark of all public releases on the open-source software that was selected. In a second step then every individual commit is benchmarked for more fine-grained data. By comparing the performance results of the pure release benchmarking and the individual commit benchmarking it is eventually possible to decide if a specific performance regression could have been detected earlier if a continuous benchmarking approach would have been used.

	\subsection{Experiment Setup}
	\label{ssec:exp_setup}
	
	To perform the experiment as described in \autoref{ssec:exp_goals} the open-source software LZ4\footnote{\url{https://github.com/lz4/lz4}} will be used. \texttt{LZ4} is a compression library with an active commit history. In total \texttt{LZ4} offers 31 releases and more than 2500 commits in total\footnote{As of 16.09.2021}. 
	
	For the benchmark itself the open source project \texttt{lzbench}\footnote{\url{https://github.com/inikep/lzbench}} will be used. Lzbench is an in-memory compression benchmarking tool that is designed to compare different implementations of compression algorithms. For this experiment all other compression algorithm implementations will be disabled so that only \texttt{lz4} will be benchmarked at different releases and commits. 
	
	Lzbench offers the option to disable all the other compression algorithms at compile time. The LZ4 version that is used for the benchmark can simply be changed by overwriting the corresponding lz4 files within the lzbench repository before compilation. In the experiment a slightly adapted version of Lzbench will be used that has the other compression algorithms disabled at compile time and also incorporates some minor changes that were required to ensure compilation on the cluster infrastructure.

	Lzbench also offers a variety of command line switches that influence the behaviour of the benchmark. An overview of the switches that were used for executing this experiment can be found in \autoref{tab:cmd_switches}\footnote{Also see: \url{https://github.com/inikep/lzbench}}.

	\begin{table}
		\caption{Overview of used command line switches for lzbench}
		\label{tab:cmd_switches}
		\centering
		\begin{tabular}{|c|c|}
			\hline
			\textbf{Switch} & \textbf{Description}\\
			\hline\hline
			\texttt{-elz4} & Limits the lzbench run to only benchmark the lz4 compression implementation \\
			\hline
			\texttt{-i100,100} & Sets the minimum number of compression and decompression iterations to $100$ \\
			\hline
			\texttt{-p3} & Sets the output to print the median speed of all iterations \\
			\hline
			\texttt{-j} & Join files in memory but compress them independently \\
			\hline
			\texttt{-r} & Operate recursively on directories \\
			\hline 
			\texttt{-o4} & Sets the output text format to CSV \\
			\hline
			\texttt{-v} & Disables progress information \\
			\hline
		\end{tabular}
	\end{table}
	
	As a workload for the compression benchmark the Silesia Data Corpus will be used\footnote{\url{http://sun.aei.polsl.pl/~sdeor/index.php?page=silesia}}. The Silesia Corpus is a diverse dataset that has specifically been designed as a compression workload with the motivation in mind to include a variety of different data sources. By this the Silesia Corpus tries to not favour any compression algorithms that perform very well on a certain type of data(TODO: Citation needed).

Since the LZ4 repository consists of over 2500 commits benchmarking each individual commit is infeasible for the scope of this paper as it would both generate too much data to evaluate properly as well as strain the available shared server resources too much. Therefore a two staged approach will be used:
\begin{itemize}
	\item In the first step, a benchmark will be performed on the publicly available releases\footnote{Based on the tags created in the GitHub repository}. The results of these benchmarks will be used to identify a commit range with a significant performance change
	\item All commits in the identified commit range will be benchmarked for a more detailed and thorough analysis.
\end{itemize}

The benchmark itself will be performed on the Cluster Infrastructure of the Software Engineering Chair of Saarland University using Slurm\footnote{See \url{https://slurm.schedmd.com/documentation.html}}. The machines that are used are part of the \texttt{kine} cluster with the following hardware configuration\footnote{CPU Information has been acquired using the \texttt{lscpu} command}:

\begin{itemize}
	\item CPU Model: Intel(R) Xeon(R) CPU E5-2630 v4 @ 2.20GHz
	\item Cores per Socket: $10$
	\item Number of Sockets: $2$
	\item Minimum CPU Frequency: $1200$ MHz
	\item Maximum CPU Frequency: $3200$ MHz
	\item Available RAM: 256 GB
\end{itemize}

For the performance change detection up to three different approaches to compare the benchmarking data will be presented. Based on the results of these approaches the questions posed in \autoref{ssec:exp_goals} will be evaluated and compared. The approaches used are defined in detail in \autoref{sec:exp_evaluation}.

	\subsection{Experiment Results}

\section{Evaluation of Performance Results}
\label{sec:exp_evaluation}
\section{Reflection}

\section{Future Work}
	
	%*********************************************************************%
	% APPENDIX                                                            %
	%*********************************************************************%
	
	% Insert the appendix here. You can alternatively include files via: \include{pathToFile}
	
	%*********************************************************************%
	% LITERATURE                                                          %
	%*********************************************************************%
	% As a recommendation JabRef might be a usefull tool for this section. Use myRefs.bib therefore
	\phantomsection
	\bibliographystyle{splncs03}
	\bibliography{literature}
\end{document}
